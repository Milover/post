package template

import (
	"bytes"
	"fmt"
	"slices"
	"text/template"

	"gopkg.in/yaml.v3"
)

type Template struct {
	Params map[string][]string `yaml:"params"`
	Src    string              `yaml:"src"`
}

// Execute executes the template using all combinations of parameter values
// as input and returns the generated bytes.
func (t Template) Execute() ([]byte, error) {
	tmpl, err := template.New("tmpl").Parse(t.Src)
	if err != nil {
		return nil, fmt.Errorf("template: %w", err)
	}
	// execute for all combinations of parameters
	var b bytes.Buffer
	par := make(map[string]string)
	combs := 1
	for i := range t.Params {
		combs *= len(t.Params[i])
	}
	for i := 0; i < combs; i++ {
		tmp := i
		for key, vals := range t.Params {
			index := tmp % len(vals)
			tmp /= len(vals)
			par[key] = vals[index]
		}
		if err := tmpl.Execute(&b, par); err != nil {
			return nil, fmt.Errorf("%w", err)
		}
	}
	return b.Bytes(), nil
}

// FindTemplates performs a per-content-node breadth-first search of n,
// looking for mappings with the 'template' tag and extracts the nodes
// containing the entire 'template' mapping.
func FindNodes(n *yaml.Node) []*yaml.Node {
	nodes := make([]*yaml.Node, 0, 5) // guesstimate
	for _, c := range n.Content {
		if c.Value == "template" {
			nodes = append(nodes, n)
			return slices.Clip(nodes)
		}
	}
	for _, c := range n.Content {
		nodes = append(nodes, FindNodes(c)...)
	}
	return slices.Clip(nodes)
}

// NodeToTemplates creates Templates from a n by extracting all
// mappings with the 'template' tag and unmarshalling them into Templates.
func NodeToTemplates(n *yaml.Node) ([]Template, error) {
	ts := make([]Template, 0, 5) // guesstimate
	for i, c := range n.Content {
		// there's like a phantom node which is just 'template', the other
		// node is the actual content, hence the 'i+1'
		if c.Value == "template" {
			var t Template
			tn := new(yaml.Node)
			if i+1 < len(n.Content) {
				tn = n.Content[i+1]
			}
			if err := tn.Decode(&t); err != nil {
				return ts, fmt.Errorf("template: %w", err)
			}
			ts = append(ts, t)
		}
	}
	for _, c := range n.Content {
		temp, err := NodeToTemplates(c)
		if err != nil {
			return ts, fmt.Errorf("template: %w", err)
		}
		ts = append(ts, temp...)
	}
	return slices.Clip(ts), nil
}
